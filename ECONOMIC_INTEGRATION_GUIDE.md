# Przewodnik Integracji Rozszerzonego Systemu Ekonomicznego

Ten dokument opisuje, jak zintegrowaƒá kompletny system ekonomiczny z grƒÖ Droga Szamana RPG.

## üìã Podsumowanie Systemu

Stworzony zosta≈Ç kompleksowy system ekonomiczny sk≈ÇadajƒÖcy siƒô z:

### üè≠ Komponenty Systemu

1. **Enhanced Economy** (`mechanics/economy.py`)
   - Rozszerzona klasa `EnhancedEconomy` dziedziczƒÖca po `Economy`
   - Integracja z AI handlarzy, wydarzeniami i ≈Ça≈Ñcuchami produkcji
   - Pe≈Çna kompatybilno≈õƒá wsteczna

2. **Economic Events** (`mechanics/economic_events.py`)
   - 12 r√≥≈ºnych typ√≥w wydarze≈Ñ ekonomicznych
   - Automatyczne generowanie i wygasanie wydarze≈Ñ
   - Wp≈Çyw na ceny, poda≈º i popyt

3. **Production Chains** (`mechanics/production_chains.py`)
   - Kompletne ≈Ça≈Ñcuchy produkcji od surowc√≥w do produkt√≥w ko≈Ñcowych
   - System jako≈õci surowc√≥w i narzƒôdzi
   - Wydobywanie zasob√≥w z wƒôz≈Ç√≥w

4. **Merchant AI** (`mechanics/merchant_ai.py`)
   - Inteligentni handlarze z pamiƒôciƒÖ i emocjami
   - System negocjacji i reputacji
   - R√≥≈ºne style handlowe i osobowo≈õci

## üîß Instrukcje Integracji

### Krok 1: Aktualizacja Game State

```python
# W core/game_state.py dodaj:

from mechanics.economy import EnhancedEconomy

class GameState:
    def __init__(self):
        # ... istniejƒÖcy kod ...
        
        # ZASTƒÑP standardowƒÖ ekonomiƒô rozszerzonƒÖ
        self.economy = EnhancedEconomy()
        
        # Dodaj handlarzy AI
        self._setup_merchant_ais()
    
    def _setup_merchant_ais(self):
        """Konfiguruje AI handlarzy na podstawie NPC√≥w z gry"""
        # Dla ka≈ºdego handlarza z data/npcs.json
        merchant_configs = [
            ("marek", "Marek Stra≈ºnik", "corruptible"),
            ("helga", "Helga Kucharka", "stingy"),
            ("olaf", "Olaf Kowal", "honest")
        ]
        
        for npc_id, name, personality in merchant_configs:
            self.economy.add_merchant_ai(npc_id, name, personality)
    
    def update(self, delta_time):
        """Aktualizuj stan gry"""
        # ... istniejƒÖcy kod ...
        
        # DODAJ aktualizacjƒô ekonomii
        self.economy.update_enhanced(self.game_time)
```

### Krok 2: Aktualizacja Command Parser

```python
# W ui/commands.py dodaj nowe komendy handlowe:

def handle_trade_command(self, args, game_state):
    """Handel z NPCami z negocjacjƒÖ"""
    if len(args) < 3:
        return "U≈ºycie: handel [npc] [przedmiot] [ilo≈õƒá] [cena?]"
    
    npc_id, item_id = args[0], args[1]
    quantity = int(args[2]) if args[2].isdigit() else 1
    offered_price = float(args[3]) if len(args) > 3 else None
    
    # Sprawd≈∫ czy NPC istnieje
    if npc_id not in game_state.economy.merchant_ais:
        return f"NPC {npc_id} nie jest handlarzem."
    
    # Pobierz aktualnƒÖ cenƒô
    current_price = game_state.economy.get_enhanced_price(
        item_id, "prison", 10, npc_id, "player"
    )
    
    # Je≈õli podano cenƒô, rozpocznij negocjacjƒô
    if offered_price:
        negotiation = game_state.economy.negotiate_price(
            npc_id, "player", item_id, offered_price, current_price, False
        )
        
        if negotiation['success']:
            result = game_state.economy.process_enhanced_trade(
                npc_id, "player", item_id, quantity
            )
            return f"{negotiation['reason']} {result['message']}"
        else:
            return negotiation['reason']
    
    # Handel bez negocjacji
    result = game_state.economy.process_enhanced_trade(
        npc_id, "player", item_id, quantity
    )
    return result['message']

def handle_market_command(self, args, game_state):
    """Poka≈º informacje o rynku"""
    economy = game_state.economy
    
    output = ["=== STAN RYNKU ==="]
    
    # Aktywne wydarzenia
    events = economy.get_active_events()
    if events:
        output.append("\nüìà WYDARZENIA EKONOMICZNE:")
        for event in events:
            output.append(f"‚Ä¢ {event}")
    
    # Ceny wybranych przedmiot√≥w
    output.append("\nüí∞ CENY RYNKOWE:")
    items = ["chleb", "miecz", "metal", "drewno"]
    for item_id in items:
        price = economy.get_enhanced_price(item_id, "prison", 10)
        output.append(f"‚Ä¢ {item_id.title()}: {price:.1f} z≈Ç")
    
    # Wska≈∫niki ekonomiczne
    indicators = economy.economic_indicators
    output.append("\nüìä WSKA≈πNIKI:")
    output.append(f"‚Ä¢ Stabilno≈õƒá rynku: {indicators['market_stability']:.1%}")
    output.append(f"‚Ä¢ Inflacja: {indicators['inflation_rate']:.2%}")
    
    return "\n".join(output)

def handle_craft_advanced_command(self, args, game_state):
    """Zaawansowany crafting z ≈Ça≈Ñcuchami produkcji"""
    if not args:
        # Poka≈º dostƒôpne ≈Ça≈Ñcuchy
        chains = game_state.economy.get_production_chains()
        if not chains:
            return "Brak dostƒôpnych ≈Ça≈Ñcuch√≥w produkcji."
        
        output = ["=== ≈ÅA≈ÉCUCHY PRODUKCJI ==="]
        for chain in chains[:10]:  # Poka≈º pierwsze 10
            output.append(f"‚Ä¢ {chain['name']} ({chain['category']})")
            output.append(f"  Trudno≈õƒá: {chain['difficulty']}, Czas: {chain['total_time']} min")
        
        return "\n".join(output)
    
    chain_id = args[0]
    
    # Sprawd≈∫ umiejƒôtno≈õci gracza (musisz dodaƒá system umiejƒôtno≈õci)
    player_skills = getattr(game_state.player, 'skills', {})
    
    # Symuluj produkcjƒô
    result = game_state.economy.simulate_production(chain_id, player_skills)
    
    if result['success']:
        return f"‚úì Uda≈Ço siƒô wyprodukowaƒá {result['produkt_koncowy']}! Jako≈õƒá: {result['jakosc_koncowa']}"
    else:
        return f"‚úó Produkcja nieudana: {result['powod']}"

# DODAJ te komendy do command_map:
self.command_map.update({
    'handel': self.handle_trade_command,
    'rynek': self.handle_market_command,
    'produkuj': self.handle_craft_advanced_command
})
```

### Krok 3: Aktualizacja GUI

```python
# W integrated_gui.py dodaj nowe panele:

def create_economy_panel(self, parent):
    """Panel ekonomiczny z informacjami o rynku"""
    economy_frame = tk.Frame(parent, bg=self.colors['panel'])
    economy_frame.grid(row=0, column=3, sticky='nsew', padx=2, pady=2)
    
    # Nag≈Ç√≥wek
    tk.Label(economy_frame, text="EKONOMIA", 
             font=self.fonts['header'], 
             bg=self.colors['panel'], 
             fg=self.colors['text']).grid(row=0, column=0, sticky='ew', pady=2)
    
    # Wydarzenia ekonomiczne
    self.events_text = tk.Text(economy_frame, width=25, height=8,
                               font=self.fonts['small'], 
                               bg=self.colors['bg'], 
                               fg=self.colors['text'], wrap=tk.WORD)
    self.events_text.grid(row=1, column=0, sticky='ew', padx=2, pady=2)
    
    # Ceny rynkowe
    self.prices_text = tk.Text(economy_frame, width=25, height=8,
                               font=self.fonts['small'],
                               bg=self.colors['bg'],
                               fg=self.colors['text'], wrap=tk.WORD)
    self.prices_text.grid(row=2, column=0, sticky='ew', padx=2, pady=2)
    
    return economy_frame

def update_economy_display(self):
    """Aktualizuje wy≈õwietlane informacje ekonomiczne"""
    if not hasattr(self, 'game_state') or not self.game_state.economy:
        return
    
    economy = self.game_state.economy
    
    # Aktualizuj wydarzenia
    self.events_text.delete(1.0, tk.END)
    events = economy.get_active_events()
    if events:
        self.events_text.insert(tk.END, "WYDARZENIA:\n")
        for event in events[:3]:  # Poka≈º tylko 3 najwa≈ºniejsze
            self.events_text.insert(tk.END, f"‚Ä¢ {event}\n")
    else:
        self.events_text.insert(tk.END, "Brak aktywnych wydarze≈Ñ.")
    
    # Aktualizuj ceny
    self.prices_text.delete(1.0, tk.END)
    self.prices_text.insert(tk.END, "CENY RYNKOWE:\n")
    items = [("Chleb", "chleb"), ("Miecz", "miecz"), ("Metal", "metal")]
    for item_name, item_id in items:
        price = economy.get_enhanced_price(item_id, "prison", 10)
        self.prices_text.insert(tk.END, f"{item_name}: {price:.1f} z≈Ç\n")

def create_merchant_dialog(self, npc_id):
    """Okno dialogowe handlu z NPCem"""
    dialog = tk.Toplevel(self.root)
    dialog.title(f"Handel z {npc_id}")
    dialog.geometry("500x400")
    dialog.configure(bg=self.colors['bg'])
    
    # Informacje o handlarzu
    merchant_info = self.game_state.economy.get_merchant_attitude(npc_id, "player")
    
    info_label = tk.Label(dialog, 
                         text=f"Stosunek: {merchant_info['attitude']}\n"
                              f"Kategoria klienta: {merchant_info['customer_tier']}\n"
                              f"Reputacja: {merchant_info['reputation']}",
                         font=self.fonts['normal'],
                         bg=self.colors['bg'],
                         fg=self.colors['text'])
    info_label.pack(pady=10)
    
    # Lista przedmiot√≥w do kupienia/sprzeda≈ºy
    # ... implementacja interfejsu handlowego ...
    
    return dialog

# DODAJ do main update loop:
def update_display(self):
    # ... istniejƒÖcy kod ...
    
    # DODAJ aktualizacjƒô ekonomii
    self.update_economy_display()
```

### Krok 4: Konfiguracja NPC√≥w

```python
# Dodaj do merge_npc_data.py lub podobnego pliku:

def setup_enhanced_npcs(game_state):
    """Konfiguruje NPC√≥w z rozszerzonymi funkcjami ekonomicznymi"""
    
    # Dla ka≈ºdego NPC okre≈õl specjalizacjƒô handlowƒÖ
    npc_specializations = {
        "marek": {"personality": "corruptible", "specializations": ["contraband", "information"]},
        "brutus": {"personality": "aggressive", "specializations": ["weapons", "intimidation"]},
        "jozek": {"personality": "wise", "specializations": ["knowledge", "tools"]},
        "anna": {"personality": "calculating", "specializations": ["lockpicks", "escape_gear"]},
        "piotr": {"personality": "gossipy", "specializations": ["information", "rumors"]}
    }
    
    # Konfiguruj handlarzy
    for npc_id, config in npc_specializations.items():
        if npc_id in game_state.economy.merchant_ais:
            merchant_ai = game_state.economy.merchant_ais[npc_id]
            merchant_ai.specializations = config["specializations"]
```

## üìä API Reference

### EnhancedEconomy

```python
economy = EnhancedEconomy()

# Dodanie handlarza AI
economy.add_merchant_ai("npc_id", "Nazwa", "personality")

# Pobieranie cen z pe≈Çnymi modyfikatorami
price = economy.get_enhanced_price("item_id", "market", base_price, "npc_id", "player_id")

# Negocjacje
result = economy.negotiate_price("npc_id", "player_id", "item_id", offered, current, is_buying)

# Transakcje
result = economy.process_enhanced_trade("seller_id", "buyer_id", "item_id", quantity)

# Informacje o wydarzeniach
events = economy.get_active_events()

# ≈Åa≈Ñcuchy produkcji
chains = economy.get_production_chains("category")
result = economy.simulate_production("chain_id", player_skills, tool_qualities)

# Stan handlarza
attitude = economy.get_merchant_attitude("npc_id", "player_id")
```

### Przyk≈Çady U≈ºycia

```python
# Automatyczne wydarzenia co godzinƒô
if game_time % 60 == 0:
    economy.update_enhanced(game_time)

# Sprawdzenie czy gracz mo≈ºe negocjowaƒá
merchant_ai = economy.merchant_ais.get("marek")
if merchant_ai and merchant_ai.negotiation_style == NegotiationStyle.ELASTYCZNY:
    # Negocjacja ma wiƒôksze szanse powodzenia

# Reakcja na wydarzenia ekonomiczne
events = economy.get_active_events()
for event_desc in events:
    if "niedob√≥r metalu" in event_desc.lower():
        show_notification("Ceny metalowych przedmiot√≥w wzros≈Çy!")
```

## üß™ Testowanie

Uruchom kompletny test suite:

```bash
python tests/test_enhanced_economy.py
```

Testy obejmujƒÖ:
- Wydarzenia ekonomiczne
- ≈Åa≈Ñcuchy produkcji  
- AI handlarzy
- Integracjƒô system√≥w
- System jako≈õci
- Save/load compatibility

## üîß RozwiƒÖzywanie Problem√≥w

### Problem: ImportError dla nowych modu≈Ç√≥w
```python
# RozwiƒÖzanie: Dodaj fallback w EnhancedEconomy.__init__
try:
    from .economic_events import EconomicEventManager
except ImportError:
    self.event_manager = None
    print("Economic events module not available")
```

### Problem: Ceny sƒÖ za wysokie/niskie
```python
# Sprawd≈∫ aktywne wydarzenia ekonomiczne
events = economy.get_active_events()
print("Active events:", events)

# Sprawd≈∫ modyfikatory cen
for item in ["metal", "chleb"]:
    modifier = economy.event_manager.get_price_modifier_for_item(item)
    print(f"{item} price modifier: {modifier}")
```

### Problem: AI handlarze nie pamiƒôtajƒÖ transakcji
```python
# Sprawd≈∫ czy transakcje sƒÖ przetwarzane przez AI
merchant_ai = economy.merchant_ais["marek"]
transactions = merchant_ai.memory.player_transactions.get("player", [])
print(f"Player transactions with Marek: {len(transactions)}")
```

## üìà Dalszy Rozw√≥j

System jest zaprojektowany do rozszerzania:

1. **Dodatkowe wydarzenia** - w `economic_events.py`
2. **Nowe ≈Ça≈Ñcuchy produkcji** - w `production_chains.py`
3. **Wiƒôcej typ√≥w handlarzy** - w `merchant_ai.py`
4. **Sezonowo≈õƒá** - ju≈º wbudowana w `EnhancedEconomy`
5. **Miƒôdzynarodowy handel** - dodatkowe rynki w systemie

## üéØ Podsumowanie

System ekonomiczny jest w pe≈Çni funkcjonalny i gotowy do integracji. Wszystkie komponenty sƒÖ przetestowane i kompatybilne z istniejƒÖcym systemem gry. Save/load jest obs≈Çugiwane automatycznie.

**Kluczowe zalety:**
- ‚úÖ ≈ªywa ekonomia z AI handlarzami
- ‚úÖ Wydarzenia wp≈ÇywajƒÖce na rynki  
- ‚úÖ Realistyczne ≈Ça≈Ñcuchy produkcji
- ‚úÖ System jako≈õci i trwa≈Ço≈õci
- ‚úÖ Pe≈Çna kompatybilno≈õƒá wsteczna
- ‚úÖ Comprehensive testing
- ‚úÖ Polish language support

System jest gotowy do u≈ºycia w produkcji!